# 虚拟内存
虚拟内存提供的功能

- 将主存看成是一个存储在磁盘上的地址空间的高速缓存，**在主存中只保存活动区域，根据需要在磁盘和主存之间来回传送数据**
- 为每个进程提供了一致的地址空间，简化内存管理
- 保护进程的地址空间不被其他进程破坏



## 虚拟内存的工作原理

### 1 物理和虚拟寻址
- **主存**：由M个连续的字节大小的单元组成的数组，每字节都有一个唯一的物理地址
- 物理寻址：直接从物理地址上取数据
- **虚拟寻址**：CPU通过生成一个虚拟地址来访问主存，这个寻你地址在被送到内存之前先转换成适当的物理地址。（地址翻译，通过CPU上的内存管理单元利用存放在主存中的**查询表**（由OS管理）来动态翻译虚拟地址。）

### 2 地址空间
是一个非负整数地址的有序集合
- 虚拟地址空间：CPU从一个地址空间中生成的虚拟地址的地址空间，以位数来表示：例如 n位地址空间
- 物理地址空间：对应于物理内存

### 3 虚拟内存作为缓存的工具
- 和存储器层次结构中的其他缓存一样，磁盘上的数据<u>被分割成块</u>，这些块作为磁盘和主存之间的<u>传输单元</u>
- 虚拟内存系统将虚拟内存分割为**虚拟页**（VP：大小固定的块）来处理问题
- **物理页**：称为页帧

**虚拟页面的集合：**

- <u>未分配的</u>：VM系统还未分配的页，不占用磁盘空间
- <u>缓存的</u>：当前已缓存在物理内存中的已分配的页
- <u>未缓存的</u>：未缓存在物理内存中已分配的页

#### 3.1 DRAM缓存的组织结构

SRAM缓存：位于CPU和主存之间的高速缓存。SRAM不命中：操作主存

DRAM缓存：虚拟内存系统的缓存，在主存中缓存虚拟页。DRAM不命中：操作磁盘。虚拟页替换算法

#### 3.2 页表

判定一个虚拟页是否缓存在DRAM中。页表存放在物理内存中，将虚拟页映射到物理内存中。（每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表）

页表：是一个页表条目的数组



（CPU通过虚拟地址到页表中查询对应的物理内存地址，页表本身存在内存中。页表拿到虚拟地址后 1虚拟地址对应的物理页号已经在内存中了，就直接到物理内存中取数据；2虚拟地址对应的物理页号不在内存中，然后到磁盘中取找，将找到的那一块空间作为虚拟内存，取其中数据然后可以由操作系统将对应的页加入到物理内存中，同时修改页表中的对应值）

#### 3.3 页命中和缺页

产生缺页后，先触发**缺页异常**从而调用内核中的<u>缺页异常处理程序</u>：选择一个牺牲页，如果该页被修改需要将该页复制回磁盘。然后内核修改页表中对应的条目，将所需要的页从磁盘复制到物理内存中换出的空间。然后缺页处理程序返回缺页的虚拟地址交给MMU再次翻译。

#### 3.4 分配页面

调用malloc是在虚拟内存上开辟一块空间，然后反映到页表中更新页表项

#### 3.5 虚拟内存作为内存管理工具

OS为每个进程提供了一个独立的页表（独立的虚拟地址空间），不同进程的页表共享同一个物理内存。

内存的使用和管理：

- 简化链接

- 简化加载

  ​	加载目标文件到一个新创建的进程中式，Linux加载器<u>为代码和数据段分配虚拟页</u>，把它们<u>置为“未被缓存”</u>，将页表条目指向目标文件中适当的位置。虚拟内存系统会按照需要自动地调入数据页。

- 简化共享

  ​	对于每个进程的私有数据，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。

- 简化内存分配

### 4 内存保护

在地址翻译虚拟内存的时候带上一些标志位，翻译出的标志位可以控制内存访问的权限。如果发生访问出错一般返回段错误。

### 5 多级页表

假设32位地址空间，4k页大小，每个PTE大小为4bit 

总共需要4M大小的页表驻留在内存

- 多级页表的划分

  一级页表中每个PTE映射虚拟地址空间中一个4MB的**片**，每一片由1024个连续的页面组成。此时，1024个PTE就可以覆盖整个4GB大小的内存空间了。

  如果某个片中至少有一个页是分配了的，那么一级PTE就指向一个二级页表的基址。

  二级页表中的每个PTE都负责映射一个4KB大小的虚拟内存页面。

### 案例

64位CPU中：支持48位（256TB）虚拟地址空间，52位（4PB）物理地址空间

Linux中页大小在启动时被配置为4KB

i7体系结构允许页表换进换出，但是与已分配的页相关的页表都是驻留在内存中的





## 虚拟内存的使用和管理

### 1 Linux虚拟内存

内核虚拟内存：每个进程共享内核的代码和全局数据结构

- Linux将虚拟内存组成一些区域（段）的集合，一个区域就是已分配的虚拟内存的连续的片，这些页是以某种方式相关联的。

内核为系统中每个进程维护一个单独的任务结构：包含指向该进层所需的所有信息。（例如pid，指向用户指针，PC等）

task_struct.mm  -> mm_struct(描述虚拟内存当前的状态).mmap -> vm_area_struct

在mm_struct中，mm_struct.pgd：指向第一级页表的基址，mm_struct.mmap指向一个vm_area_struct区域结构链表。链表中的每一项描述了当前虚拟地址空间的一个区域。

#### 缺页异常处理

在MMU翻译某个虚拟地址A时触发了缺页，之后：

- 虚拟地址A是否合法？（A是否在某个区域结构vm_area_struct定义的区域内？）（在链表中对比查找：实际是在链表上构建了树进行查找，找不到返回段错误）
- 试图进行的内存访问是否合法？（是否有访问该内存权限，错误返回保护异常）
- 将虚拟内存对应的页换入物理内存，更新页表
- 缺页处理程序返回，然后CPU重启原指令再次发送虚拟地址A到MMU翻译



### 2 内存映射

Linux将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容

虚拟内存区域可以映射到<u>Linux文件系统中的普通文件</u>和<u>匿名文件</u>

一旦一个虚拟页被初始化了，它就在一个由内核维护的专门的交换文件（交换空间）之间换来换去

映射到进程上的共享对象被修改时会反映到磁盘上，对于其他进程而言修改也是可见的。相反，修改私有对象不修改磁盘数据对其他进程不可见



- 私有对象使用：写时复制技术

  区域结构被标记为“**私有的写时复制**”，没有进程写该私有区域时他们就共享物理内存中对象的一个单独副本，一旦有进程要写私有区域中的某个页面，就触发一个**保护故障**

  故障处理程序在物理内存中创建这个页面的一个新的副本，更新页表项目指向这个新的副本，恢复这个页面的可写权限

- fork：fork被父进程调用时，新进程创建了父进程的mm_struct，区域结构和页表的原样副本。将父子进程中的每个页面都标记为只读，并将两个进程中每个区域结构都标记为私有的写时复制；fork在子进程中返回时，子进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当父子进程任意一个进行写时，写时复制技术会创建新页面。（这里针对的是每个进的私有地址空间） ->  <u>(是否两个都创建)</u>

- execve：加载并运行可执行程序的几个步骤：

  1 删除已存在的用户区域  2映射私有区域  3 映射共享区域  4设置PC（指向代码区域的入口点）

```c
// mmap要求内核创建一个新的虚拟内存区域，将fd所指定对象的一个连续的片（length字节）映射到这个新的区域
// prot为虚拟内存区域访问的权限位
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *addr, size_t length);
```



### 3 动态内存分配

**动态内存分配器**维护一个进程的<u>虚拟内存区域</u>（称为堆）。

进程空间分布：

- 用户栈：从高地址网低地址方向分配空间
- 代码段，位于最底层
- 已初始化数据和未初始化数据，位于代码段上方
- 堆，位于未初始化数据段的上方，并向上生长。进程中内核维护的变量brk指向堆顶
- 在堆和栈之间可以有共享的内存映射区域

进分配器将堆视为一组不同大小的块，每个块是一个连续的虚拟内存片（已分配状态或者空闲状态）。

分配器的基本风格：

- 显示分配器
- 隐式分配器：垃圾收集器。自动释放未使用的已分配的块

```c
void *malloc(size_t size);
void free(void *ptr);

void *calloc(size_t nmemb, size_t size); // 将分配的内存初始化为0

```

```c
int brk(void *addr);
// 通过将内核的brk指针增加incr来扩展和收缩堆。如果成功，返回brk旧值。负值incr返回brk旧值指向距离新堆顶向上abs(incr)字节处
void *sbrk(intptr_t increment);

```

#### 碎片

堆碎片：

- 1 内部碎片：是在一个已分配快有效载荷大时发生的。
- 2 外部碎片：当空闲内存合计起来足够满足一个分配请求，但是没有一个单独块足够大的来处理请求

#### 如何实现？

- 如何记录空闲块？
- 如何选择空闲位置来放置新分配的块？
- 放置到一个块后，如何处理块中剩余的部分？
- 如何处理（合并）一个刚刚被释放的块？

#### 隐式空闲链表

分配器需要一些数据结构：一个块是由一个字的头部、有效载荷、可能的一些额外填充组成。

其中，头部编码了块的大小，块已分配还是空闲。

隐式空闲链表：空闲块是通过头部中的大小字段来隐含地连接着的。

分配器可以通过便利堆中所有的块从而间接地遍历整个空闲块的集合。

#### 放置已分配的块

当一个应用请求k字节的块时，分配器搜索空闲链表，查找一个足够大（足以容下k字节）的空闲空间。通过**放置策略**来查找

放置策略有：首次适配，下一次适配，最佳适配

#### 分割空闲块

#### 获取额外的堆内存

如果通过合并空闲块也无法满足请求分配的大小，分配器会通过调用sbrk向内核请求额外的堆内存。

将额外内存转化为大的空闲块插入到空闲链表中

#### 合并空闲块

释放已分配块时

何时执行合并？

- 立即合并
- 推迟合并（直到有分配失败时，再扫描进行分配）

#### 带边界标记的合并





### 垃圾收集

垃圾收集器：是一种动态内存分配器，自动释放程序不再需要的已分配块。自动回收堆存储的过程称为来及收集。

垃圾收集器将内存视为一张<u>有向可达图</u>：堆节点对应于堆中的一个已分配块。有向边p->q表示块p中的某个位置指向q中的某个位置，根节点对应于这种不再堆中的位置（寄存器、栈的变量），它们中包含指针指向堆中的指针。

当存在一条从任意根节点出发并到达p的有向路径时，则 节点p是可达的。

任何时刻，不可达节点对应于垃圾，不能被应用再次使用。

垃圾收集器维护可达图，释放不可达节点并且将他们返回个空闲链表来定期回收它们。

但是，c/c++中每个可达块能被精确表示，不可达块可能表示出错，所以需要通过free将他们返回给堆。