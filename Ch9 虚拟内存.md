# 虚拟内存
虚拟内存提供的功能

- 将主存看成是一个存储在磁盘上的地址空间的高速缓存，**在主存中只保存活动区域，根据需要在磁盘和主存之间来回传送数据**
- 为每个进程提供了一致的地址空间，简化内存管理
- 保护进程的地址空间不被其他进程破坏



## 虚拟内存的工作原理

### 1 物理和虚拟寻址
- **主存**：由M个连续的字节大小的单元组成的数组，每字节都有一个唯一的物理地址
- 物理寻址：直接从物理地址上取数据
- **虚拟寻址**：CPU通过生成一个虚拟地址来访问主存，这个寻你地址在被送到内训之前先转换成适当的物理地址。（地址翻译，通过CPU上的内存管理单元利用存放在主存中的**查询表**（由OS管理）来动态翻译虚拟地址。）

### 2 地址空间
是一个非负整数地址的有序集合
- 虚拟地址空间：CPU从一个地址空间中生成的虚拟地址的地址空间，以位数来表示：例如 n位地址空间
- 物理地址空间：对应于物理内存

### 3 虚拟内存作为缓存的工具
- 和存储器层次结构中的其他缓存一样，磁盘上的数据<u>被分割成块</u>，这些块作为磁盘和主存之间的<u>传输单元</u>
- 虚拟内存系统将虚拟内存分割为**虚拟页**（VP：大小固定的块）来处理问题
- **物理页**：称为页帧

**虚拟页面的集合：**

- <u>未分配的</u>：VM系统还未分配的页，不占用磁盘空间
- <u>缓存的</u>：当前已缓存在物理内存中的已分配的页
- <u>未缓存的</u>：未缓存在物理内存中已分配的页

#### 3.1 DRAM缓存的组织结构

SRAM缓存：位于CPU和主存之间的高速缓存。SRAM不命中：操作主存

DRAM缓存：虚拟内存系统的缓存，在主存中缓存虚拟页。DRAM不命中：操作磁盘。虚拟页替换算法

#### 3.2 页表

判定一个虚拟页是否缓存在DRAM中。页表存放在物理内存中，将虚拟页映射到物理内存中。（每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表）

页表：是一个页表条目的数组



（CPU通过虚拟地址到页表中查询对应的物理内存地址，页表本身存在内存中。页表拿到虚拟地址后 1虚拟地址对应的物理页号已经在内存中了，就直接到物理内存中取数据；2虚拟地址对应的物理页号不在内存中，然后到磁盘中取找，将找到的那一块空间作为虚拟内存，取其中数据然后可以由操作系统将对应的页加入到物理内存中，同时修改页表中的对应值）

#### 3.3 页命中和缺页

产生缺页后，先触发**缺页异常**从而调用内核中的<u>缺页异常处理程序</u>：选择一个牺牲页，如果该页被修改需要将该页复制回磁盘。然后内核修改页表中对应的条目，将所需要的页从磁盘复制到物理内存中换出的空间。然后缺页处理程序返回缺页的虚拟地址交给MMU再次翻译。

#### 3.4 分配页面

调用malloc是在虚拟内存上开辟一块空间，然后反映到页表中更新页表项

#### 3.5 虚拟内存作为内存管理工具

OS为每个进程提供了一个独立的页表（独立的虚拟地址空间），不同进程的页表共享同一个物理内存。

内存的使用和管理：

- 简化链接

- 简化加载

  ​	加载目标文件到一个新创建的进程中式，Linux加载器<u>为代码和数据段分配虚拟页</u>，把它们<u>置为“未被缓存”</u>，将页表条目指向目标文件中适当的位置。虚拟内存系统会按照需要自动地调入数据页。

- 简化共享

  ​	对于每个进程的私有数据，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。

- 简化内存分配

### 4 内存保护

在地址翻译虚拟内存的时候带上一些标志位，翻译出的标志位可以控制内存访问的权限。如果发生访问出错一般返回段错误。

### 5 多级页表

假设32位地址空间，4k页大小，每个PTE大小为4bit 

总共需要4M大小的页表驻留在内存

- 多级页表的划分

  一级页表中每个PTE映射虚拟地址空间中一个4MB的**片**，每一片由1024个连续的页面组成。此时，1024个PTE就可以覆盖整个4GB大小的内存空间了。

  如果某个片中至少有一个页是分配了的，那么一级PTE就指向一个二级页表的基址。

  二级页表中的每个PTE都负责映射一个4KB大小的虚拟内存页面。

### 案例

64位CPU中：支持48位（256TB）虚拟地址空间，52位（4PB）物理地址空间

Linux中页大小在启动时被配置为4KB

i7体系结构允许页表换进换出，但是与已分配的页相关的页表都是驻留在内存中的





## 虚拟内存的使用和管理

### 1 Linux虚拟内存

内核虚拟内存：每个进程共享内核的代码和全局数据结构

- Linux将虚拟内存组成一些区域（段）的集合，一个区域就是已分配的虚拟内存的连续的片，这些页是以某种方式相关联的。

内核为系统中每个进程维护一个单独的任务结构：包含指向该进层所需的所有信息。（例如pid，指向用户指针，PC等）

task_struct.mm  -> mm_struct(描述虚拟内存当前的状态).mmap -> vm_area_struct

在mm_struct中，mm_struct.pgd：指向第一级页表的基址，mm_struct.mmap指向一个vm_area_struct区域结构链表。链表中的每一项描述了当前虚拟地址空间的一个区域。

#### 缺页异常处理

在MMU翻译某个虚拟地址A时触发了缺页，之后：

- 虚拟地址A是否合法？（A是否在某个区域结构vm_area_struct定义的区域内？）（在链表中对比查找：实际是在链表上构建了树进行查找，找不到返回段错误）
- 试图进行的内存访问是否合法？（是否有访问该内存权限，错误返回保护异常）
- 将虚拟内存对应的页换入物理内存，更新页表
- 缺页处理程序返回，然后CPU重启原指令再次发送虚拟地址A到MMU翻译



### 2 内存映射

Linux将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容

虚拟内存区域可以映射到<u>Linux文件系统中的普通文件</u>和<u>匿名文件</u>

一旦一个虚拟页被初始化了，它就在一个由内核维护的专门的交换文件（交换空间）之间换来换去

映射到进程上的共享对象被修改时会反映到磁盘上，对于其他进程而言修改也是可见的。相反，修改私有对象不修改磁盘数据对其他进程不可见



- 私有对象使用：写时复制技术

  区域结构被标记为“**私有的写时复制**”，没有进程写该私有区域时他们就共享物理内存中对象的一个单独副本，一旦有进程要写私有区域中的某个页面，就出发一个**保护故障**

  故障处理程序在物理内存中创建这个页面的一个新的副本，更新页表项目指向这个新的副本，恢复这个页面的可写权限

- fork：fork被父进程调用时，新进程创建了父进程的mm_struct，区域结构和页表的原样副本。将父子进程中的每个页面都标记为只读，并将连个进程中每个区域结构都标记为私有的写时复制；fork在子进程中返回时，子进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当父子进程任意一个进行写时，写时复制技术会创建新页面。（这里针对的是每个进的私有地址空间）

- execve：加载并运行可执行程序的几个步骤：

  1 删除已存在的用户区域  2映射私有区域  3 映射共享区域  4设置PC（指向代码区域的入口点）

```c
// mmap要求内核创建一个新的虚拟内存区域，将fd所指定对象的一个连续的片（length字节）映射到这个新的区域
// prot为虚拟内存区域访问的权限位
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *addr, size_t length);
```



### 3 动态内存分配

